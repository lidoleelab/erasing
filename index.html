<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Residual Birth by Digitizing</title>

<style>
:root{
  --bg:#ffffff;
  --ui:#666;
  --track:#e0e0e0;
  --fill:#888;     /* waveform + slider fill */
  --thumb:#888;
}

*{ box-sizing:border-box; }

body{
  margin:0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background: var(--bg);
  color:#111;
}

.wrap{
  max-width: 860px;
  margin: 40px auto;
  padding: 0 16px 40px;
}

.stack{
  display: grid;
  grid-template-columns: 1fr;
  gap: 28px;
}

.player{
  display: grid;
  grid-template-columns: auto auto 1fr auto auto auto;
  align-items: center;
  gap: 14px;
  width: 100%;
  padding-bottom: 12px;
}

.btn{
  border: none;
  background: transparent;
  padding: 0;
  cursor: pointer;
}

.btn svg{
  width: 24px;
  height: 24px;
  fill: var(--ui);
}

.time, .dur{
  font-variant-numeric: tabular-nums;
  color: var(--ui);
  font-size: 14px;
  min-width: 46px;
}

/* slider */
.range{
  width: 100%;
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  border-radius: 999px;
  background: linear-gradient(to right,
    var(--fill) 0%,
    var(--fill) var(--pct,0%),
    var(--track) var(--pct,0%),
    var(--track) 100%);
  outline: none;
}

.range::-webkit-slider-thumb{
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: var(--thumb);
  cursor: pointer;
}

.range::-moz-range-thumb{
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: var(--thumb);
  cursor: pointer;
}

.icon{
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.icon svg{
  width: 20px;
  height: 20px;
  fill: var(--ui);
}

.vol{ width: 120px; }

/* ===== seek + waveform line ===== */
.seekwrap{
  display: grid;
  gap: 10px;
  align-items: center;
}

.wave{
  width: 100%;
  height: 34px;           /* editor-like height */
  display: block;
  border-radius: 6px;
  background: transparent;
  cursor: pointer;
}
</style>
</head>

<body>
<div class="wrap">
  <section class="stack">

    <!-- PLAYER 1 -->
    <div class="player" data-player>
      <button class="btn" data-play aria-label="play/pause">
        <svg viewBox="0 0 24 24" data-ico><path d="M8 5v14l11-7z"/></svg>
      </button>
      <div class="time" data-current>0:00</div>

      <div class="seekwrap">
        <input class="range" type="range" min="0" max="100" value="0" step="0.1" data-seek>
        <canvas class="wave" height="34" data-wave></canvas>
      </div>

      <div class="dur" data-duration>0:00</div>

      <div class="icon" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M3 10v4h4l5 4V6L7 10H3zm13.5 2a3.5 3.5 0 0 0-2-3.16v6.32A3.5 3.5 0 0 0 16.5 12zm0-7a8.5 8.5 0 0 1 0 14v-2a6.5 6.5 0 0 0 0-10V5z"/></svg>
      </div>

      <input class="range vol" type="range" min="0" max="1" value="1" step="0.01" data-vol aria-label="volume">

      <audio preload="metadata" data-audio>
        <source src="audio/01_original.mp3" type="audio/mpeg">
      </audio>
    </div>

    <!-- PLAYER 2 -->
    <div class="player" data-player>
      <button class="btn" data-play aria-label="play/pause">
        <svg viewBox="0 0 24 24" data-ico><path d="M8 5v14l11-7z"/></svg>
      </button>
      <div class="time" data-current>0:00</div>

      <div class="seekwrap">
        <input class="range" type="range" min="0" max="100" value="0" step="0.1" data-seek>
        <canvas class="wave" height="34" data-wave></canvas>
      </div>

      <div class="dur" data-duration>0:00</div>

      <div class="icon" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M3 10v4h4l5 4V6L7 10H3zm13.5 2a3.5 3.5 0 0 0-2-3.16v6.32A3.5 3.5 0 0 0 16.5 12zm0-7a8.5 8.5 0 0 1 0 14v-2a6.5 6.5 0 0 0 0-10V5z"/></svg>
      </div>

      <input class="range vol" type="range" min="0" max="1" value="1" step="0.01" data-vol aria-label="volume">

      <audio preload="metadata" data-audio>
        <source src="audio/02_denoised.mp3" type="audio/mpeg">
      </audio>
    </div>

    <!-- PLAYER 3 -->
    <div class="player" data-player>
      <button class="btn" data-play aria-label="play/pause">
        <svg viewBox="0 0 24 24" data-ico><path d="M8 5v14l11-7z"/></svg>
      </button>
      <div class="time" data-current>0:00</div>

      <div class="seekwrap">
        <input class="range" type="range" min="0" max="100" value="0" step="0.1" data-seek>
        <canvas class="wave" height="34" data-wave></canvas>
      </div>

      <div class="dur" data-duration>0:00</div>

      <div class="icon" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M3 10v4h4l5 4V6L7 10H3zm13.5 2a3.5 3.5 0 0 0-2-3.16v6.32A3.5 3.5 0 0 0 16.5 12zm0-7a8.5 8.5 0 0 1 0 14v-2a6.5 6.5 0 0 0 0-10V5z"/></svg>
      </div>

      <input class="range vol" type="range" min="0" max="1" value="1" step="0.01" data-vol aria-label="volume">

      <audio preload="metadata" data-audio>
        <source src="audio/03_no_noise_no_bgm.mp3" type="audio/mpeg">
      </audio>
    </div>

    <!-- PLAYER 4 -->
    <div class="player" data-player>
      <button class="btn" data-play aria-label="play/pause">
        <svg viewBox="0 0 24 24" data-ico><path d="M8 5v14l11-7z"/></svg>
      </button>
      <div class="time" data-current>0:00</div>

      <div class="seekwrap">
        <input class="range" type="range" min="0" max="100" value="0" step="0.1" data-seek>
        <canvas class="wave" height="34" data-wave></canvas>
      </div>

      <div class="dur" data-duration>0:00</div>

      <div class="icon" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M3 10v4h4l5 4V6L7 10H3zm13.5 2a3.5 3.5 0 0 0-2-3.16v6.32A3.5 3.5 0 0 0 16.5 12zm0-7a8.5 8.5 0 0 1 0 14v-2a6.5 6.5 0 0 0 0-10V5z"/></svg>
      </div>

      <input class="range vol" type="range" min="0" max="1" value="1" step="0.01" data-vol aria-label="volume">

      <audio preload="metadata" data-audio>
        <source src="audio/04_residual.mp3" type="audio/mpeg">
      </audio>
    </div>

  </section>
</div>

<script>
/* =========================
   Waveform line preview (FIXED)
   - peaks are generated at fixed resolution (independent of canvas width)
   - canvas re-draws automatically on resize (ResizeObserver)
   - highlights played portion + playhead
========================= */

const setPct = (el,p)=>el.style.setProperty('--pct',`${p}%`);

const players = [];
let audioCtx = null;

function getAudioCtx(){
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}
async function resumeAudioCtx(){
  const c = getAudioCtx();
  if (c.state === "suspended"){
    try { await c.resume(); } catch {}
  }
}

const fmtTime = (sec) => {
  sec = Math.max(0, sec || 0);
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${String(s).padStart(2,'0')}`;
};

function getSourceUrl(audioEl){
  const src = audioEl.querySelector("source");
  return src ? src.getAttribute("src") : audioEl.currentSrc;
}

/* cache: url -> peaks (Float32Array 0..1) */
const waveformCache = new Map();

/* fixed-res peaks so initial canvas width doesn't matter */
const PEAKS_RESOLUTION = 2200;

function computePeaks(channelData, count){
  const len = channelData.length;
  const block = Math.floor(len / count) || 1;
  const peaks = new Float32Array(count);

  for (let i = 0; i < count; i++){
    const start = i * block;
    const end = Math.min(start + block, len);
    let max = 0;
    for (let j = start; j < end; j++){
      const v = Math.abs(channelData[j]);
      if (v > max) max = v;
    }
    peaks[i] = max;
  }
  return peaks;
}

function drawWaveLine(canvas, peaks, progress01 = 0){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const W = Math.max(1, canvas.clientWidth || 1);
  const H = Math.max(1, canvas.clientHeight || 34);

  canvas.width = Math.floor(W * dpr);
  canvas.height = Math.floor(H * dpr);

  const g = canvas.getContext("2d");
  g.setTransform(dpr, 0, 0, dpr, 0, 0);
  g.clearRect(0, 0, W, H);

  const mid = H / 2;

  const baseFill   = "#cfcfcf";
  const playedFill = "#888888";
  const stroke     = "#777777";
  const playhead   = "#666666";

  // Resample peaks -> pixels (one sample per x)
  const N = peaks.length;
  const pxCount = Math.max(2, Math.floor(W)); // ~1 per pixel

  const getPeakAtX = (xIdx) => {
    const t = xIdx / (pxCount - 1);
    const idx = Math.min(N - 1, Math.max(0, Math.floor(t * (N - 1))));
    return peaks[idx];
  };

  const playedX = Math.max(0, Math.min(pxCount - 1, Math.floor(progress01 * (pxCount - 1))));

  // Fill envelope region helper
  function fillEnvelope(endX, fillStyle){
    g.beginPath();
    // top
    for (let x = 0; x <= endX; x++){
      const p = getPeakAtX(x);
      const X = (x / (pxCount - 1)) * W;
      const Y = mid - p * (H * 0.45);
      if (x === 0) g.moveTo(X, Y);
      else g.lineTo(X, Y);
    }
    // bottom
    for (let x = endX; x >= 0; x--){
      const p = getPeakAtX(x);
      const X = (x / (pxCount - 1)) * W;
      const Y = mid + p * (H * 0.45);
      g.lineTo(X, Y);
    }
    g.closePath();
    g.fillStyle = fillStyle;
    g.fill();
  }

  // Full (unplayed)
  fillEnvelope(pxCount - 1, baseFill);

  // Played overlay
  if (progress01 > 0){
    fillEnvelope(playedX, playedFill);
  }

  // Outline stroke
  g.beginPath();
  for (let x = 0; x < pxCount; x++){
    const p = getPeakAtX(x);
    const X = (x / (pxCount - 1)) * W;
    const Y = mid - p * (H * 0.45);
    if (x === 0) g.moveTo(X, Y);
    else g.lineTo(X, Y);
  }
  for (let x = pxCount - 1; x >= 0; x--){
    const p = getPeakAtX(x);
    const X = (x / (pxCount - 1)) * W;
    const Y = mid + p * (H * 0.45);
    g.lineTo(X, Y);
  }
  g.closePath();
  g.strokeStyle = stroke;
  g.lineWidth = 1;
  g.stroke();

  // Playhead
  const px = progress01 * W;
  g.fillStyle = playhead;
  g.fillRect(px, 0, 1, H);
}

async function ensureWaveform(audioEl, canvas){
  const url = getSourceUrl(audioEl);
  if (!url || !canvas) return null;

  const redraw = (progress01=0) => {
    const peaks = waveformCache.get(url);
    if (peaks) drawWaveLine(canvas, peaks, progress01);
  };

  if (waveformCache.has(url)){
    redraw(0);
    return redraw;
  }

  const c = getAudioCtx();
  const res = await fetch(url);
  if (!res.ok) throw new Error("Failed to fetch audio: " + url);
  const arr = await res.arrayBuffer();
  const buf = await c.decodeAudioData(arr);

  const ch0 = buf.getChannelData(0);
  const peaks = computePeaks(ch0, PEAKS_RESOLUTION);

  waveformCache.set(url, peaks);
  redraw(0);
  return redraw;
}

/* =========================
   Player wiring
========================= */
document.querySelectorAll('[data-player]').forEach(root=>{
  const audio = root.querySelector('[data-audio]');
  const playBtn = root.querySelector('[data-play]');
  const ico = root.querySelector('[data-ico]');
  const seek = root.querySelector('[data-seek]');
  const vol = root.querySelector('[data-vol]');
  const cur = root.querySelector('[data-current]');
  const dur = root.querySelector('[data-duration]');
  const waveCanvas = root.querySelector('[data-wave]');

  players.push({ audio });

  // slider fill init
  setPct(vol, Number(vol.value) * 100);

  let redrawWave = null;

  // ✅ preload waveform BEFORE play
  ensureWaveform(audio, waveCanvas)
    .then(fn => { redrawWave = fn; })
    .catch(() => { /* ignore */ });

  // ✅ redraw reliably when canvas width becomes valid / changes
  if (waveCanvas && "ResizeObserver" in window){
    const ro = new ResizeObserver(() => {
      if (!redrawWave) return;
      const progress01 = audio.duration ? (audio.currentTime / audio.duration) : 0;
      redrawWave(progress01);
    });
    ro.observe(waveCanvas);
  }

  audio.addEventListener('loadedmetadata',()=>{
    dur.textContent = fmtTime(audio.duration);
    if (redrawWave) redrawWave(0);
  });

  audio.addEventListener('timeupdate',()=>{
    cur.textContent = fmtTime(audio.currentTime);
    const p = audio.duration ? (audio.currentTime / audio.duration) * 100 : 0;
    seek.value = p;
    setPct(seek, p);

    if (redrawWave){
      const progress01 = audio.duration ? (audio.currentTime / audio.duration) : 0;
      redrawWave(progress01);
    }
  });

  audio.addEventListener('play',()=>{
    players.forEach(p=>{
      if (p.audio !== audio && !p.audio.paused) p.audio.pause();
    });
    ico.innerHTML = '<path d="M6 5h4v14H6zm8 0h4v14h-4z"/>';
  });

  audio.addEventListener('pause',()=>{
    ico.innerHTML = '<path d="M8 5v14l11-7z"/>';
  });

  playBtn.addEventListener('click', async ()=>{
    await resumeAudioCtx();
    audio.paused ? audio.play() : audio.pause();
  });

  seek.addEventListener('input',()=>{
    const t = (seek.value/100) * (audio.duration || 0);
    cur.textContent = fmtTime(t);
    setPct(seek, seek.value);
    if (redrawWave) redrawWave(seek.value/100);
  });

  seek.addEventListener('change',()=>{
    audio.currentTime = (seek.value/100) * (audio.duration || 0);
  });

  // click waveform to seek
  if (waveCanvas){
    waveCanvas.addEventListener("click", (e) => {
      if (!audio.duration) return;
      const rect = waveCanvas.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
      const progress = rect.width ? (x / rect.width) : 0;
      audio.currentTime = progress * audio.duration;
    });
  }

  vol.addEventListener('input',()=>{
    const v = Number(vol.value);
    setPct(vol, v*100);
    audio.volume = v;
  });
});
</script>

<script>
/* =========================
   iframe height messenger
========================= */
function sendHeight(){
  const h = document.documentElement.scrollHeight;
  parent.postMessage({ type: "ERASING_HEIGHT", height: h }, "*");
}
window.addEventListener("load", sendHeight);
window.addEventListener("resize", sendHeight);
document.querySelectorAll("audio").forEach(a=>{
  a.addEventListener("loadedmetadata", sendHeight);
});
</script>

</body>
</html>
